# 一、函数
## 函数的定义
- 函数以def关键字开头，后接函数名和()
- 函数的执行代码以冒号开始，并且缩进
- return[表达式]结束函数，选择性的返回一个值给调用方。不带表达式的return相当于返回None
## 函数参数
1、位置参数
```
def myFunction(arg1):
  ......
```
2、默认参数
```
def myFunction(arg1=x):
  ......
```
3、可变参数：允许传入零个到任意个参数，它们在函数调用时自动组装成一个元组
```
def myFunction(*args):
  ......
```
4、关键字参数：允许传入零个到任意个参数，它们在函数调用时自动组装成一个字典
```
def myFunction(**kwargs):
  ......
```
5、命名关键字参数：调用这个函数时，不能缺少*后面的参数的参数名（myFunction(x1, arg2=x2)，而不能myFunction(x1, x2)）
```
def myFunction(arg1, *, arg2):
  ......
```
6、组合参数
- 参数的顺序必须是：位置参数、默认参数、可变参数、关键字参数
- 命名关键字参数和可变参数不能同时出现
## 变量作用域
- 定义在函数内部的变量拥有局部作用域，该变量称为局部变量（局部变量只能在被声明的函数内部访问）
- 定义在函数外部的变量拥有全局作用域，该变量称为全局变量（全局变量可以在整个程序范围内访问）
- global：当函数内部需要修改全局变量时，需要使用global关键字标记要修改的变量（不标记的话，修改的全局变量只在这个函数内部生效）
- nonlocal：当内嵌函数需要修改外部函数的变量时，需要使用nonlocal关键字表要修改的变量
## 内嵌函数
函数fun1中存在函数fun2，此时函数fun2就是内嵌函数
## 闭包
函数fun1中存在函数fun2，且函数fun1的返回值是函数fun2，此时函数fun2就是闭包
## 递归
一个函数在其内部调用自己本身，这个函数就是递归
# lambad表达式
## 匿名函数的定义
匿名函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间的参数
```
fun1 = lambad x1, x2: x1 + x2
x3 = fun1(x1, x2)
```
## 匿名函数的应用
匿名函数 常常应用于函数式编程的高阶函数，通常有两种形式：
- 参数是函数 (filter, map)
```
fun1 = filter(lambda x: x % 2 == 1, list(range(10)))
```
- 返回值是函数 (closure)
```
def fun1(fun, seq):
  return fun(seq)
```
# 二、类与对象
## 对象 = 属性 + 方法
- 封装：信息隐蔽技术
```
class MyClass:
  pass
class MyClass(object):
  pass
```
- 继承：子类自动共享父类之间数据和方法的机制
```
class MyClass(父类):
  pass
```
- 多态：不同对象对同一方法响应不同的行动
```
class Animal:
    def run(self):
        raise AttributeError('子类必须实现这个方法')
class Pig(Animal):
    def run(self):
        print('pig is walking')
class Dog(Animal):
    def run(self):
        print('dog is running')
def func(animal):
    animal.run()
func(Pig())
```
## self是什么？
Python中的self相当于C++中的this
- 类的方法与普通的函数只有一个特别的区别——它们的第一参数必须是self，在调用方法是不需要提供与self对应的参数
## 公有和私有
在Python中定义私有属性只需要在变量名或函数名前加上“\_\_”两个下划线，这个函数或变量就是私有的了
## 继承
- 基类必须与派生类定义在一个作用域内
- 子类中存在于父类相同的属性或属性，则会自动覆盖父类对应的属性和方法
- Python支持多继承（不建议使用，容易造成混乱）
## 组合
```
class Turtle:
    def __init__(self, x):
        self.num = x


class Fish:
    def __init__(self, x):
        self.num = x


class Pool:
    def __init__(self, x, y):
        self.turtle = Turtle(x)
        self.fish = Fish(y)

    def print_num(self):
        print("水池里面有乌龟%s只，小鱼%s条" % (self.turtle.num, self.fish.num))
```
## 类、类对象和实例对象
- 类对象：创建一个类，其实也就是在内存空间开辟了一块空间，称为类对象，类对象只有一个
- 实例对象：通过实例化创建的对象，称为实例对象，实例对象可以有多个
- 类属性：类里面方法外面定义的属性称为类属性。类属性属于类对象，且多个实例对象之间共享同一个类属性
- 实例属性：实例属性和具体的某个实例对象有关，并且一个实例对象和另一个实例对象是不共享属性的
## 一些相关的内置函数（BIF）
- issubclass(class, classinfo)：用于类class是否是类型参数classinfo的子类
- isinstance(object, classinfo)：用于判断一个对象是否是一个已知类型，考虑继承关系
- type()：返回一个对象的类型，不考虑继承关系
- hasattr(object, name)：用于判断对象是否包含对应的属性
- getattr(object, name[, default])：用于返回一个对象属性值
- setattr(object, name, value)：用于设置属性值，该属性不一定是存在的
- delattr(object, name)：用于删除属性
# 三、魔法方法
## 基本的魔法方法
- \_\_init\_\_(self[, ...])：构造器，当一个对象被创建的实例调用的初始化方法
- \_\_new\_\_(cls[, ...])：在一个对象实例化的时候所调用的第一个方法，在调用\_\_ini\_\_初始化前，先调用\_\_new\_\_
  - \_\_new\_\_至少要有一个参数cls，代表要实例化的类，此参数在实例化时由 Python 解释器自动提供，后面的参数直接传递给\_\_init\_\_
  - \_\_new\_\_对当前类进行了实例化，并将实例返回，传给\_\_init\_\_的self。但是，执行了\_\_new\_\_，并不一定会进入\_\_init\_\_，只有\_\_new\_\_返回了，当前类cls的实例，当前类的\_\_init\_\_才会进入
  - 若\_\_new\_\_没有正确返回当前类的cls实例，那么\_\_init\_\_就不会调用，即使是父类的实例也不行，将没有\_\_init\_\_调用
  - \_\_new\_\_方法主要是当你继承一些不可变的class时（比如int，str，tuple），提供给你一个自定义这些类的实例化过程的途径
- \_\_del\_\_(self)：析构器，当一个对象将要被系统回收时调用的方法
- \_\_str\_\_(self)：
  - 打印一个对象时触发
  - 使用%s格式化时触发
  - str强转数据类型时触发
  - \_\_str\_\_的返回结果可读性强
- \_\_repr\_\_(self)：
  - 是\_\_str\_\_的备胎
  - 有\_\_str\_\_方法时执行\_\_str\_\_方法，没有就执行\_\_repr\_\_方法
  - repr(object)内置函数对应的结果是\_\_repr\_\_的返回值
  - 使用%r格式化时触发
  - \_\_repr\_\_返回的结果更准确
## 算术运算符
类型工厂函数，指的是“不通过类而是通过函数来创建对象”
- \_\_add\_\_(self, other)：定义加法的行为（+）
- \_\_sub\_\_(self, other)：定义减法的行为（-）
- \_\_mul\_\_(self, other)：定义乘法的行为（*）
- \_\_truediv\_\_(self, other)：定义真除法的行为（/）
- \_\_floordiv(self, other)：定义整数除法的行为（//）
- \_\_mod\_\_(self, other)：定义取模算法的行为（%）
- \_\_divmod\_\_(self, other)：定义当被divmod()调用时的行为
- divmod(a, b)：把除数和余数的运算结果结合起来，以元组的形式返回(a // b, a % b)
- \_\_pow\_\_(self, other[, module])：定义当被pow()调用或(\*\*)运算时的行为
- \_\_lshift\_\_(self, other)：定义左位移时的行为（<<）
- \_\_rshift\_\_(self, other)：定义右位移时的行为（>>）
- \_\_and\_\_(self, other)：定义按位与操作的行为（&）
- \_\_xor\_\_(self, other)：定义按位异或操作的行为（^）
- \_\_or\_\_(self, other)：定义按位或操作的行为（|）
## 反算术运算符
反运算魔方方法，与算术运算符保持一一对应，不同之处就是反运算的魔法方法多了一个“r”。**当a中不存在该算法方法时，调用b中的反算术方法，此时b就变成了self，a为other**
- \_\_radd\_\_(self, other)定义加法的行为：+
- \_\_rsub\_\_(self, other)定义减法的行为：-
- \_\_rmul\_\_(self, other)定义乘法的行为：*
- \_\_rtruediv\_\_(self, other)定义真除法的行为：/
- \_\_rfloordiv\_\_(self, other)定义整数除法的行为：//
- \_\_rmod\_\_(self, other) 定义取模算法的行为：%
- \_\_rdivmod\_\_(self, other)定义当被 divmod() 调用时的行为
- \_\_rpow\_\_(self, other[, module])定义当被 power() 调用或 ** 运算时的行为
- \_\_rlshift\_\_(self, other)定义按位左移位的行为：<<
- \_\_rrshift\_\_(self, other)定义按位右移位的行为：>>
- \_\_rand\_\_(self, other)定义按位与操作的行为：&
- \_\_rxor\_\_(self, other)定义按位异或操作的行为：^
- \_\_ror\_\_(self, other)定义按位或操作的行为：|
